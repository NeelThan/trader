// Multi-Timeframe Swing Detection & Fibonacci Levels
// Shows swing highs/lows and Fibonacci levels from ALL timeframes on one chart
// Matches Workflow V2 backend algorithm (trader/pivots.py, trader/fibonacci.py)
//
// Features:
// - View swing points from 1M, 1W, 1D, 4H, 1H, 15m, 1m on any chart
// - Per-timeframe lookback settings
// - Per-timeframe Fibonacci level controls
// - Per-timeframe ratio selection
// - Combined trend analysis across all timeframes

//@version=6
indicator("MTF Swing Detection & Fibonacci", overlay=true, max_labels_count=500, max_lines_count=500)

// =============================================================================
// TIMEFRAME DEFINITIONS
// =============================================================================

TF_1M  = "1M"
TF_1W  = "1W"
TF_1D  = "1D"
TF_4H  = "240"
TF_1H  = "60"
TF_15m = "15"
TF_1m  = "1"

// =============================================================================
// USER-DEFINED TYPES (UDTs)
// =============================================================================

// Stores alternating pivot data for ABC pattern detection
// A = oldest, B = middle, C = most recent (chronological order)
type TFData
    float pivotA = na
    float pivotB = na
    float pivotC = na
    string lastType = ""
    float lastH = na
    float lastL = na

// =============================================================================
// GLOBAL SETTINGS
// =============================================================================

grpGlobal = "Global Display"
showTrendPanel = input.bool(true, "Show Trend Panel", group=grpGlobal)

grpTrend = "Trend Detection"
rsiPeriod = input.int(14, "RSI Period", minval=2, maxval=50, group=grpTrend)
macdFast = input.int(12, "MACD Fast", minval=2, maxval=50, group=grpTrend)
macdSlow = input.int(26, "MACD Slow", minval=2, maxval=100, group=grpTrend)
macdSignalPeriod = input.int(9, "MACD Signal", minval=2, maxval=50, group=grpTrend)

// =============================================================================
// LINE LENGTH BY TIMEFRAME (higher TF = longer lines for visibility when stacked)
// =============================================================================
// Solid lines = Swing High/Low markers (the detected pivot points)
// Dashed lines = Fibonacci levels (retracement, extension, projection, expansion)
// High/Low in table = The actual swing high/low prices detected for that timeframe

lineLen1M   = 100  // Monthly - longest (most important levels)
lineLen1W   = 85   // Weekly
lineLen1D   = 70   // Daily
lineLen4H   = 55   // 4 Hour
lineLen1H   = 40   // 1 Hour
lineLen15m  = 25   // 15 Minute
lineLen1min = 10   // 1 Minute - shortest

// =============================================================================
// 1M MONTHLY (All settings in one collapsible group)
// =============================================================================

grp1M = "═══ 1M MONTHLY ═══"
enable1M = input.bool(true, "Enable", group=grp1M, inline="1m1")
col1M = input.color(color.purple, "", group=grp1M, inline="1m1")
lb1M = input.int(3, "Left", minval=1, maxval=20, group=grp1M, inline="1m1", tooltip="Bars to left for pivot confirmation")
fwd1M = input.int(3, "Right", minval=1, maxval=20, group=grp1M, inline="1m1", tooltip="Bars to right for pivot confirmation")
showLabels1M = input.bool(true, "Labels", group=grp1M, inline="1m2")
showLines1M = input.bool(true, "Lines", group=grp1M, inline="1m2")
showPrice1M = input.bool(true, "Price", group=grp1M, inline="1m2")
extendFib1M = input.bool(true, "Extend", group=grp1M, inline="1m2")
// Retracement
ret1M = input.bool(true, "Retracement", group=grp1M, inline="1mr0")
r1M_R236 = input.bool(false, "23.6", group=grp1M, inline="1mr1")
r1M_R382 = input.bool(true, "38.2", group=grp1M, inline="1mr1")
r1M_R500 = input.bool(true, "50", group=grp1M, inline="1mr1")
r1M_R618 = input.bool(true, "61.8", group=grp1M, inline="1mr1")
r1M_R786 = input.bool(true, "78.6", group=grp1M, inline="1mr1")
// Extension
ext1M = input.bool(true, "Extension", group=grp1M, inline="1me0")
r1M_E1272 = input.bool(true, "127.2", group=grp1M, inline="1me1")
r1M_E1618 = input.bool(true, "161.8", group=grp1M, inline="1me1")
r1M_E2000 = input.bool(false, "200", group=grp1M, inline="1me1")
r1M_E2618 = input.bool(false, "261.8", group=grp1M, inline="1me1")
// Projection
proj1M = input.bool(false, "Projection", group=grp1M, inline="1mp0")
r1M_P618 = input.bool(true, "61.8", group=grp1M, inline="1mp1")
r1M_P786 = input.bool(true, "78.6", group=grp1M, inline="1mp1")
r1M_P1000 = input.bool(true, "100", group=grp1M, inline="1mp1")
r1M_P1272 = input.bool(true, "127.2", group=grp1M, inline="1mp1")
r1M_P1618 = input.bool(false, "161.8", group=grp1M, inline="1mp1")
// Expansion
exp1M = input.bool(false, "Expansion", group=grp1M, inline="1mx0")
r1M_X382 = input.bool(true, "38.2", group=grp1M, inline="1mx1")
r1M_X500 = input.bool(true, "50", group=grp1M, inline="1mx1")
r1M_X618 = input.bool(true, "61.8", group=grp1M, inline="1mx1")
r1M_X1000 = input.bool(true, "100", group=grp1M, inline="1mx1")
r1M_X1618 = input.bool(false, "161.8", group=grp1M, inline="1mx1")
// ABC Points (for Projection/Expansion)
autoABC1M = input.bool(true, "Auto ABC", group=grp1M, inline="1mabc", tooltip="Use auto-detected pivots for A, B, C points")
manualA1M = input.float(0.0, "A", group=grp1M, inline="1mabc")
manualB1M = input.float(0.0, "B", group=grp1M, inline="1mabc")
manualC1M = input.float(0.0, "C", group=grp1M, inline="1mabc")

// =============================================================================
// 1W WEEKLY (All settings in one collapsible group)
// =============================================================================

grp1W = "═══ 1W WEEKLY ═══"
enable1W = input.bool(true, "Enable", group=grp1W, inline="1w1")
col1W = input.color(color.blue, "", group=grp1W, inline="1w1")
lb1W = input.int(3, "Left", minval=1, maxval=20, group=grp1W, inline="1w1", tooltip="Bars to left for pivot confirmation")
fwd1W = input.int(3, "Right", minval=1, maxval=20, group=grp1W, inline="1w1", tooltip="Bars to right for pivot confirmation")
showLabels1W = input.bool(true, "Labels", group=grp1W, inline="1w2")
showLines1W = input.bool(true, "Lines", group=grp1W, inline="1w2")
showPrice1W = input.bool(true, "Price", group=grp1W, inline="1w2")
extendFib1W = input.bool(true, "Extend", group=grp1W, inline="1w2")
// Retracement
ret1W = input.bool(true, "Retracement", group=grp1W, inline="1wr0")
r1W_R236 = input.bool(false, "23.6", group=grp1W, inline="1wr1")
r1W_R382 = input.bool(true, "38.2", group=grp1W, inline="1wr1")
r1W_R500 = input.bool(true, "50", group=grp1W, inline="1wr1")
r1W_R618 = input.bool(true, "61.8", group=grp1W, inline="1wr1")
r1W_R786 = input.bool(true, "78.6", group=grp1W, inline="1wr1")
// Extension
ext1W = input.bool(true, "Extension", group=grp1W, inline="1we0")
r1W_E1272 = input.bool(true, "127.2", group=grp1W, inline="1we1")
r1W_E1618 = input.bool(true, "161.8", group=grp1W, inline="1we1")
r1W_E2000 = input.bool(false, "200", group=grp1W, inline="1we1")
r1W_E2618 = input.bool(false, "261.8", group=grp1W, inline="1we1")
// Projection
proj1W = input.bool(false, "Projection", group=grp1W, inline="1wp0")
r1W_P618 = input.bool(true, "61.8", group=grp1W, inline="1wp1")
r1W_P786 = input.bool(true, "78.6", group=grp1W, inline="1wp1")
r1W_P1000 = input.bool(true, "100", group=grp1W, inline="1wp1")
r1W_P1272 = input.bool(true, "127.2", group=grp1W, inline="1wp1")
r1W_P1618 = input.bool(false, "161.8", group=grp1W, inline="1wp1")
// Expansion
exp1W = input.bool(false, "Expansion", group=grp1W, inline="1wx0")
r1W_X382 = input.bool(true, "38.2", group=grp1W, inline="1wx1")
r1W_X500 = input.bool(true, "50", group=grp1W, inline="1wx1")
r1W_X618 = input.bool(true, "61.8", group=grp1W, inline="1wx1")
r1W_X1000 = input.bool(true, "100", group=grp1W, inline="1wx1")
r1W_X1618 = input.bool(false, "161.8", group=grp1W, inline="1wx1")
// ABC Points (for Projection/Expansion)
autoABC1W = input.bool(true, "Auto ABC", group=grp1W, inline="1wabc", tooltip="Use auto-detected pivots for A, B, C points")
manualA1W = input.float(0.0, "A", group=grp1W, inline="1wabc")
manualB1W = input.float(0.0, "B", group=grp1W, inline="1wabc")
manualC1W = input.float(0.0, "C", group=grp1W, inline="1wabc")

// =============================================================================
// 1D DAILY (All settings in one collapsible group)
// =============================================================================

grp1D = "═══ 1D DAILY ═══"
enable1D = input.bool(true, "Enable", group=grp1D, inline="1d1")
col1D = input.color(color.teal, "", group=grp1D, inline="1d1")
lb1D = input.int(5, "Left", minval=1, maxval=20, group=grp1D, inline="1d1", tooltip="Bars to left for pivot confirmation")
fwd1D = input.int(5, "Right", minval=1, maxval=20, group=grp1D, inline="1d1", tooltip="Bars to right for pivot confirmation")
showLabels1D = input.bool(true, "Labels", group=grp1D, inline="1d2")
showLines1D = input.bool(true, "Lines", group=grp1D, inline="1d2")
showPrice1D = input.bool(true, "Price", group=grp1D, inline="1d2")
extendFib1D = input.bool(true, "Extend", group=grp1D, inline="1d2")
// Retracement
ret1D = input.bool(true, "Retracement", group=grp1D, inline="1dr0")
r1D_R236 = input.bool(false, "23.6", group=grp1D, inline="1dr1")
r1D_R382 = input.bool(true, "38.2", group=grp1D, inline="1dr1")
r1D_R500 = input.bool(true, "50", group=grp1D, inline="1dr1")
r1D_R618 = input.bool(true, "61.8", group=grp1D, inline="1dr1")
r1D_R786 = input.bool(true, "78.6", group=grp1D, inline="1dr1")
// Extension
ext1D = input.bool(true, "Extension", group=grp1D, inline="1de0")
r1D_E1272 = input.bool(true, "127.2", group=grp1D, inline="1de1")
r1D_E1618 = input.bool(true, "161.8", group=grp1D, inline="1de1")
r1D_E2000 = input.bool(false, "200", group=grp1D, inline="1de1")
r1D_E2618 = input.bool(false, "261.8", group=grp1D, inline="1de1")
// Projection
proj1D = input.bool(false, "Projection", group=grp1D, inline="1dp0")
r1D_P618 = input.bool(true, "61.8", group=grp1D, inline="1dp1")
r1D_P786 = input.bool(true, "78.6", group=grp1D, inline="1dp1")
r1D_P1000 = input.bool(true, "100", group=grp1D, inline="1dp1")
r1D_P1272 = input.bool(true, "127.2", group=grp1D, inline="1dp1")
r1D_P1618 = input.bool(false, "161.8", group=grp1D, inline="1dp1")
// Expansion
exp1D = input.bool(false, "Expansion", group=grp1D, inline="1dx0")
r1D_X382 = input.bool(true, "38.2", group=grp1D, inline="1dx1")
r1D_X500 = input.bool(true, "50", group=grp1D, inline="1dx1")
r1D_X618 = input.bool(true, "61.8", group=grp1D, inline="1dx1")
r1D_X1000 = input.bool(true, "100", group=grp1D, inline="1dx1")
r1D_X1618 = input.bool(false, "161.8", group=grp1D, inline="1dx1")
// ABC Points (for Projection/Expansion)
autoABC1D = input.bool(true, "Auto ABC", group=grp1D, inline="1dabc", tooltip="Use auto-detected pivots for A, B, C points")
manualA1D = input.float(0.0, "A", group=grp1D, inline="1dabc")
manualB1D = input.float(0.0, "B", group=grp1D, inline="1dabc")
manualC1D = input.float(0.0, "C", group=grp1D, inline="1dabc")

// =============================================================================
// 4H FOUR HOUR (All settings in one collapsible group)
// =============================================================================

grp4H = "═══ 4H FOUR HOUR ═══"
enable4H = input.bool(true, "Enable", group=grp4H, inline="4h1")
col4H = input.color(color.green, "", group=grp4H, inline="4h1")
lb4H = input.int(5, "Left", minval=1, maxval=20, group=grp4H, inline="4h1", tooltip="Bars to left for pivot confirmation")
fwd4H = input.int(5, "Right", minval=1, maxval=20, group=grp4H, inline="4h1", tooltip="Bars to right for pivot confirmation")
showLabels4H = input.bool(true, "Labels", group=grp4H, inline="4h2")
showLines4H = input.bool(true, "Lines", group=grp4H, inline="4h2")
showPrice4H = input.bool(true, "Price", group=grp4H, inline="4h2")
extendFib4H = input.bool(true, "Extend", group=grp4H, inline="4h2")
// Retracement
ret4H = input.bool(true, "Retracement", group=grp4H, inline="4hr0")
r4H_R236 = input.bool(false, "23.6", group=grp4H, inline="4hr1")
r4H_R382 = input.bool(true, "38.2", group=grp4H, inline="4hr1")
r4H_R500 = input.bool(true, "50", group=grp4H, inline="4hr1")
r4H_R618 = input.bool(true, "61.8", group=grp4H, inline="4hr1")
r4H_R786 = input.bool(true, "78.6", group=grp4H, inline="4hr1")
// Extension
ext4H = input.bool(true, "Extension", group=grp4H, inline="4he0")
r4H_E1272 = input.bool(true, "127.2", group=grp4H, inline="4he1")
r4H_E1618 = input.bool(true, "161.8", group=grp4H, inline="4he1")
r4H_E2000 = input.bool(false, "200", group=grp4H, inline="4he1")
r4H_E2618 = input.bool(false, "261.8", group=grp4H, inline="4he1")
// Projection
proj4H = input.bool(false, "Projection", group=grp4H, inline="4hp0")
r4H_P618 = input.bool(true, "61.8", group=grp4H, inline="4hp1")
r4H_P786 = input.bool(true, "78.6", group=grp4H, inline="4hp1")
r4H_P1000 = input.bool(true, "100", group=grp4H, inline="4hp1")
r4H_P1272 = input.bool(true, "127.2", group=grp4H, inline="4hp1")
r4H_P1618 = input.bool(false, "161.8", group=grp4H, inline="4hp1")
// Expansion
exp4H = input.bool(false, "Expansion", group=grp4H, inline="4hx0")
r4H_X382 = input.bool(true, "38.2", group=grp4H, inline="4hx1")
r4H_X500 = input.bool(true, "50", group=grp4H, inline="4hx1")
r4H_X618 = input.bool(true, "61.8", group=grp4H, inline="4hx1")
r4H_X1000 = input.bool(true, "100", group=grp4H, inline="4hx1")
r4H_X1618 = input.bool(false, "161.8", group=grp4H, inline="4hx1")
// ABC Points (for Projection/Expansion)
autoABC4H = input.bool(true, "Auto ABC", group=grp4H, inline="4habc", tooltip="Use auto-detected pivots for A, B, C points")
manualA4H = input.float(0.0, "A", group=grp4H, inline="4habc")
manualB4H = input.float(0.0, "B", group=grp4H, inline="4habc")
manualC4H = input.float(0.0, "C", group=grp4H, inline="4habc")

// =============================================================================
// 1H ONE HOUR (All settings in one collapsible group)
// =============================================================================

grp1H = "═══ 1H ONE HOUR ═══"
enable1H = input.bool(true, "Enable", group=grp1H, inline="1h1")
col1H = input.color(color.orange, "", group=grp1H, inline="1h1")
lb1H = input.int(5, "Left", minval=1, maxval=20, group=grp1H, inline="1h1", tooltip="Bars to left for pivot confirmation")
fwd1H = input.int(5, "Right", minval=1, maxval=20, group=grp1H, inline="1h1", tooltip="Bars to right for pivot confirmation")
showLabels1H = input.bool(true, "Labels", group=grp1H, inline="1h2")
showLines1H = input.bool(true, "Lines", group=grp1H, inline="1h2")
showPrice1H = input.bool(true, "Price", group=grp1H, inline="1h2")
extendFib1H = input.bool(true, "Extend", group=grp1H, inline="1h2")
// Retracement
ret1H = input.bool(true, "Retracement", group=grp1H, inline="1hr0")
r1H_R236 = input.bool(false, "23.6", group=grp1H, inline="1hr1")
r1H_R382 = input.bool(true, "38.2", group=grp1H, inline="1hr1")
r1H_R500 = input.bool(true, "50", group=grp1H, inline="1hr1")
r1H_R618 = input.bool(true, "61.8", group=grp1H, inline="1hr1")
r1H_R786 = input.bool(true, "78.6", group=grp1H, inline="1hr1")
// Extension
ext1H = input.bool(true, "Extension", group=grp1H, inline="1he0")
r1H_E1272 = input.bool(true, "127.2", group=grp1H, inline="1he1")
r1H_E1618 = input.bool(true, "161.8", group=grp1H, inline="1he1")
r1H_E2000 = input.bool(false, "200", group=grp1H, inline="1he1")
r1H_E2618 = input.bool(false, "261.8", group=grp1H, inline="1he1")
// Projection
proj1H = input.bool(false, "Projection", group=grp1H, inline="1hp0")
r1H_P618 = input.bool(true, "61.8", group=grp1H, inline="1hp1")
r1H_P786 = input.bool(true, "78.6", group=grp1H, inline="1hp1")
r1H_P1000 = input.bool(true, "100", group=grp1H, inline="1hp1")
r1H_P1272 = input.bool(true, "127.2", group=grp1H, inline="1hp1")
r1H_P1618 = input.bool(false, "161.8", group=grp1H, inline="1hp1")
// Expansion
exp1H = input.bool(false, "Expansion", group=grp1H, inline="1hx0")
r1H_X382 = input.bool(true, "38.2", group=grp1H, inline="1hx1")
r1H_X500 = input.bool(true, "50", group=grp1H, inline="1hx1")
r1H_X618 = input.bool(true, "61.8", group=grp1H, inline="1hx1")
r1H_X1000 = input.bool(true, "100", group=grp1H, inline="1hx1")
r1H_X1618 = input.bool(false, "161.8", group=grp1H, inline="1hx1")
// ABC Points (for Projection/Expansion)
autoABC1H = input.bool(true, "Auto ABC", group=grp1H, inline="1habc", tooltip="Use auto-detected pivots for A, B, C points")
manualA1H = input.float(0.0, "A", group=grp1H, inline="1habc")
manualB1H = input.float(0.0, "B", group=grp1H, inline="1habc")
manualC1H = input.float(0.0, "C", group=grp1H, inline="1habc")

// =============================================================================
// 15m FIFTEEN MIN (All settings in one collapsible group)
// =============================================================================

grp15m = "═══ 15m FIFTEEN MIN ═══"
enable15m = input.bool(false, "Enable", group=grp15m, inline="15m1")
col15m = input.color(color.red, "", group=grp15m, inline="15m1")
lb15m = input.int(5, "Left", minval=1, maxval=20, group=grp15m, inline="15m1", tooltip="Bars to left for pivot confirmation")
fwd15m = input.int(5, "Right", minval=1, maxval=20, group=grp15m, inline="15m1", tooltip="Bars to right for pivot confirmation")
showLabels15m = input.bool(true, "Labels", group=grp15m, inline="15m2")
showLines15m = input.bool(true, "Lines", group=grp15m, inline="15m2")
showPrice15m = input.bool(true, "Price", group=grp15m, inline="15m2")
extendFib15m = input.bool(true, "Extend", group=grp15m, inline="15m2")
// Retracement
ret15m = input.bool(true, "Retracement", group=grp15m, inline="15mr0")
r15m_R236 = input.bool(false, "23.6", group=grp15m, inline="15mr1")
r15m_R382 = input.bool(true, "38.2", group=grp15m, inline="15mr1")
r15m_R500 = input.bool(true, "50", group=grp15m, inline="15mr1")
r15m_R618 = input.bool(true, "61.8", group=grp15m, inline="15mr1")
r15m_R786 = input.bool(true, "78.6", group=grp15m, inline="15mr1")
// Extension
ext15m = input.bool(true, "Extension", group=grp15m, inline="15me0")
r15m_E1272 = input.bool(true, "127.2", group=grp15m, inline="15me1")
r15m_E1618 = input.bool(true, "161.8", group=grp15m, inline="15me1")
r15m_E2000 = input.bool(false, "200", group=grp15m, inline="15me1")
r15m_E2618 = input.bool(false, "261.8", group=grp15m, inline="15me1")
// Projection
proj15m = input.bool(false, "Projection", group=grp15m, inline="15mp0")
r15m_P618 = input.bool(true, "61.8", group=grp15m, inline="15mp1")
r15m_P786 = input.bool(true, "78.6", group=grp15m, inline="15mp1")
r15m_P1000 = input.bool(true, "100", group=grp15m, inline="15mp1")
r15m_P1272 = input.bool(true, "127.2", group=grp15m, inline="15mp1")
r15m_P1618 = input.bool(false, "161.8", group=grp15m, inline="15mp1")
// Expansion
exp15m = input.bool(false, "Expansion", group=grp15m, inline="15mx0")
r15m_X382 = input.bool(true, "38.2", group=grp15m, inline="15mx1")
r15m_X500 = input.bool(true, "50", group=grp15m, inline="15mx1")
r15m_X618 = input.bool(true, "61.8", group=grp15m, inline="15mx1")
r15m_X1000 = input.bool(true, "100", group=grp15m, inline="15mx1")
r15m_X1618 = input.bool(false, "161.8", group=grp15m, inline="15mx1")
// ABC Points (for Projection/Expansion)
autoABC15m = input.bool(true, "Auto ABC", group=grp15m, inline="15mabc", tooltip="Use auto-detected pivots for A, B, C points")
manualA15m = input.float(0.0, "A", group=grp15m, inline="15mabc")
manualB15m = input.float(0.0, "B", group=grp15m, inline="15mabc")
manualC15m = input.float(0.0, "C", group=grp15m, inline="15mabc")

// =============================================================================
// 1m ONE MIN (All settings in one collapsible group)
// =============================================================================

grp1min = "═══ 1m ONE MIN ═══"
enable1min = input.bool(false, "Enable", group=grp1min, inline="1min1")
col1min = input.color(color.gray, "", group=grp1min, inline="1min1")
lb1min = input.int(5, "Left", minval=1, maxval=20, group=grp1min, inline="1min1", tooltip="Bars to left for pivot confirmation")
fwd1min = input.int(5, "Right", minval=1, maxval=20, group=grp1min, inline="1min1", tooltip="Bars to right for pivot confirmation")
showLabels1min = input.bool(true, "Labels", group=grp1min, inline="1min2")
showLines1min = input.bool(true, "Lines", group=grp1min, inline="1min2")
showPrice1min = input.bool(true, "Price", group=grp1min, inline="1min2")
extendFib1min = input.bool(true, "Extend", group=grp1min, inline="1min2")
// Retracement
ret1min = input.bool(true, "Retracement", group=grp1min, inline="1minr0")
r1min_R236 = input.bool(false, "23.6", group=grp1min, inline="1minr1")
r1min_R382 = input.bool(true, "38.2", group=grp1min, inline="1minr1")
r1min_R500 = input.bool(true, "50", group=grp1min, inline="1minr1")
r1min_R618 = input.bool(true, "61.8", group=grp1min, inline="1minr1")
r1min_R786 = input.bool(true, "78.6", group=grp1min, inline="1minr1")
// Extension
ext1min = input.bool(true, "Extension", group=grp1min, inline="1mine0")
r1min_E1272 = input.bool(true, "127.2", group=grp1min, inline="1mine1")
r1min_E1618 = input.bool(true, "161.8", group=grp1min, inline="1mine1")
r1min_E2000 = input.bool(false, "200", group=grp1min, inline="1mine1")
r1min_E2618 = input.bool(false, "261.8", group=grp1min, inline="1mine1")
// Projection
proj1min = input.bool(false, "Projection", group=grp1min, inline="1minp0")
r1min_P618 = input.bool(true, "61.8", group=grp1min, inline="1minp1")
r1min_P786 = input.bool(true, "78.6", group=grp1min, inline="1minp1")
r1min_P1000 = input.bool(true, "100", group=grp1min, inline="1minp1")
r1min_P1272 = input.bool(true, "127.2", group=grp1min, inline="1minp1")
r1min_P1618 = input.bool(false, "161.8", group=grp1min, inline="1minp1")
// Expansion
exp1min = input.bool(false, "Expansion", group=grp1min, inline="1minx0")
r1min_X382 = input.bool(true, "38.2", group=grp1min, inline="1minx1")
r1min_X500 = input.bool(true, "50", group=grp1min, inline="1minx1")
r1min_X618 = input.bool(true, "61.8", group=grp1min, inline="1minx1")
r1min_X1000 = input.bool(true, "100", group=grp1min, inline="1minx1")
r1min_X1618 = input.bool(false, "161.8", group=grp1min, inline="1minx1")
// ABC Points (for Projection/Expansion)
autoABC1min = input.bool(true, "Auto ABC", group=grp1min, inline="1minabc", tooltip="Use auto-detected pivots for A, B, C points")
manualA1min = input.float(0.0, "A", group=grp1min, inline="1minabc")
manualB1min = input.float(0.0, "B", group=grp1min, inline="1minabc")
manualC1min = input.float(0.0, "C", group=grp1min, inline="1minabc")

// =============================================================================
// HELPER FUNCTIONS
// =============================================================================

// Check if we have valid ABC data for a timeframe (at least one point exists)
hasValidABCData(float pA, float pB, float pC) =>
    not na(pA) or not na(pB) or not na(pC)

// Convert lastType to swing direction for Fibonacci calculations
// "low" = swing ended LOW = DOWN direction = BUY setup
// "high" = swing ended HIGH = UP direction = SELL setup
getSwingDir(string lastType) =>
    lastType == "low" ? "down" : (lastType == "high" ? "up" : "down")

// Check if current TF can request target TF data
// Returns true for same/higher TF targets (always allowed)
// Returns true for lower TF targets only on low TF charts (Pine Script limit)
isValidTFRequest(string targetTF) =>
    currentMins = timeframe.in_seconds() / 60
    targetMins = switch targetTF
        "1M" => 43200
        "1W" => 10080
        "1D" => 1440
        "240" => 240
        "60" => 60
        "15" => 15
        "1" => 1
        => 1440
    // Allow if current TF <= target TF (requesting same or higher TF)
    // Monthly can be 28-31 days so use >= comparison with some tolerance
    currentMins <= targetMins * 1.1  // 10% tolerance for month variations

// Fibonacci calculations
calcRetracement(float h, float l, string dir, float ratio) =>
    rng = h - l
    dir == "down" ? h - (rng * ratio) : l + (rng * ratio)

calcExtension(float h, float l, string dir, float ratio) =>
    rng = h - l
    dir == "down" ? h - (rng * ratio) : l + (rng * ratio)

calcProjection(float a, float b, float c, string dir, float ratio) =>
    swing = math.abs(a - b)
    dir == "down" ? c - (swing * ratio) : c + (swing * ratio)

calcExpansion(float a, float b, string dir, float ratio) =>
    rng = math.abs(a - b)
    dir == "down" ? b - (rng * ratio) : b + (rng * ratio)

// Update pivot storage with new swing high/low data
// When alternating (high→low or low→high): shift pattern (A←B, B←C, C←new)
// When same type: update C with latest value (keeps ABC current)
updatePivots(TFData tf, float sh, float sl) =>
    if not na(sh)
        tf.lastH := sh
        if tf.lastType != "high"
            tf.pivotA := tf.pivotB
            tf.pivotB := tf.pivotC
            tf.pivotC := sh
            tf.lastType := "high"
        else
            tf.pivotC := sh
    if not na(sl)
        tf.lastL := sl
        if tf.lastType != "low"
            tf.pivotA := tf.pivotB
            tf.pivotB := tf.pivotC
            tf.pivotC := sl
            tf.lastType := "low"
        else
            tf.pivotC := sl

// Get computed ABC point (auto-detected or manual override)
getABCPoint(float autoVal, bool useAuto, float manualVal) =>
    useAuto ? autoVal : (manualVal > 0 ? manualVal : autoVal)

// Draw a single trend table row, returns trend direction ("BULL", "BEAR", "RANG")
drawTrendRow(table tbl, int row, string tfName, color tfCol, bool autoABC,
             float pA, float pB, float pC, float rsi, float macdHist, int lb, int fwd) =>
    t = getTrendSignal(rsi, macdHist)
    d = getTrendDir(t)
    c = getTrendCol(d)
    mode = autoABC ? "" : "*"
    table.cell(tbl, 0, row, tfName + mode, text_color=tfCol, text_size=size.tiny)
    table.cell(tbl, 1, row, na(pA) ? "-" : str.tostring(pA, format.mintick), text_color=color.yellow, text_size=size.tiny)
    table.cell(tbl, 2, row, na(pB) ? "-" : str.tostring(pB, format.mintick), text_color=color.lime, text_size=size.tiny)
    table.cell(tbl, 3, row, na(pC) ? "-" : str.tostring(pC, format.mintick), text_color=color.aqua, text_size=size.tiny)
    table.cell(tbl, 4, row, d, text_color=c, text_size=size.tiny)
    table.cell(tbl, 5, row, str.tostring(rsi, "#.#"), text_color=rsi > 50 ? color.lime : color.red, text_size=size.tiny)
    table.cell(tbl, 6, row, macdHist > 0 ? "+" : "-", text_color=macdHist > 0 ? color.lime : color.red, text_size=size.tiny)
    table.cell(tbl, 7, row, str.tostring(lb) + "/" + str.tostring(fwd), text_color=color.gray, text_size=size.tiny)
    d

// =============================================================================
// PIVOT DETECTION FUNCTIONS
// =============================================================================

// Use Pine's built-in pivot functions for more reliable MTF detection
// lb = left bars (lookback), rb = right bars (forward confirmation)
getPivotHigh(int lb, int rb) =>
    ta.pivothigh(high, lb, rb)

getPivotLow(int lb, int rb) =>
    ta.pivotlow(low, lb, rb)

getMacdHist(int fast, int slow, int sig) =>
    [macdLine, signalLine, histLine] = ta.macd(close, fast, slow, sig)
    histLine

// =============================================================================
// MULTI-TIMEFRAME DATA REQUESTS
// =============================================================================

// 1M
[sh1M, sl1M, rsi1M, mh1M] = request.security(syminfo.tickerid, TF_1M,
    [getPivotHigh(lb1M, fwd1M), getPivotLow(lb1M, fwd1M), ta.rsi(close, rsiPeriod), getMacdHist(macdFast, macdSlow, macdSignalPeriod)],
    lookahead=barmerge.lookahead_on)

// 1W
[sh1W, sl1W, rsi1W, mh1W] = request.security(syminfo.tickerid, TF_1W,
    [getPivotHigh(lb1W, fwd1W), getPivotLow(lb1W, fwd1W), ta.rsi(close, rsiPeriod), getMacdHist(macdFast, macdSlow, macdSignalPeriod)],
    lookahead=barmerge.lookahead_on)

// 1D
[sh1D, sl1D, rsi1D, mh1D] = request.security(syminfo.tickerid, TF_1D,
    [getPivotHigh(lb1D, fwd1D), getPivotLow(lb1D, fwd1D), ta.rsi(close, rsiPeriod), getMacdHist(macdFast, macdSlow, macdSignalPeriod)],
    lookahead=barmerge.lookahead_on)

// 4H
[sh4H, sl4H, rsi4H, mh4H] = request.security(syminfo.tickerid, TF_4H,
    [getPivotHigh(lb4H, fwd4H), getPivotLow(lb4H, fwd4H), ta.rsi(close, rsiPeriod), getMacdHist(macdFast, macdSlow, macdSignalPeriod)],
    lookahead=barmerge.lookahead_on)

// 1H
[sh1H, sl1H, rsi1H, mh1H] = request.security(syminfo.tickerid, TF_1H,
    [getPivotHigh(lb1H, fwd1H), getPivotLow(lb1H, fwd1H), ta.rsi(close, rsiPeriod), getMacdHist(macdFast, macdSlow, macdSignalPeriod)],
    lookahead=barmerge.lookahead_on)

// 15m
[sh15m, sl15m, rsi15m, mh15m] = request.security(syminfo.tickerid, TF_15m,
    [getPivotHigh(lb15m, fwd15m), getPivotLow(lb15m, fwd15m), ta.rsi(close, rsiPeriod), getMacdHist(macdFast, macdSlow, macdSignalPeriod)],
    lookahead=barmerge.lookahead_on)

// 1m
[sh1min, sl1min, rsi1min, mh1min] = request.security(syminfo.tickerid, TF_1m,
    [getPivotHigh(lb1min, fwd1min), getPivotLow(lb1min, fwd1min), ta.rsi(close, rsiPeriod), getMacdHist(macdFast, macdSlow, macdSignalPeriod)],
    lookahead=barmerge.lookahead_on)

// =============================================================================
// PERSISTENT SWING STORAGE (using TFData UDT)
// =============================================================================
// For proper ABC projection patterns, we need 3 ALTERNATING pivots:
// - Long pattern: A=Low, B=High, C=Low (buy on pullback)
// - Short pattern: A=High, B=Low, C=High (sell on rally)

var TFData tf1M   = TFData.new()
var TFData tf1W   = TFData.new()
var TFData tf1D   = TFData.new()
var TFData tf4H   = TFData.new()
var TFData tf1H   = TFData.new()
var TFData tf15m  = TFData.new()
var TFData tf1min = TFData.new()

// Update all timeframe pivots
updatePivots(tf1M,   sh1M,   sl1M)
updatePivots(tf1W,   sh1W,   sl1W)
updatePivots(tf1D,   sh1D,   sl1D)
updatePivots(tf4H,   sh4H,   sl4H)
updatePivots(tf1H,   sh1H,   sl1H)
updatePivots(tf15m,  sh15m,  sl15m)
updatePivots(tf1min, sh1min, sl1min)

// =============================================================================
// COMPUTED ABC POINTS (auto-detected or manual override)
// =============================================================================

pointA1M   = getABCPoint(tf1M.pivotA,   autoABC1M,   manualA1M)
pointB1M   = getABCPoint(tf1M.pivotB,   autoABC1M,   manualB1M)
pointC1M   = getABCPoint(tf1M.pivotC,   autoABC1M,   manualC1M)

pointA1W   = getABCPoint(tf1W.pivotA,   autoABC1W,   manualA1W)
pointB1W   = getABCPoint(tf1W.pivotB,   autoABC1W,   manualB1W)
pointC1W   = getABCPoint(tf1W.pivotC,   autoABC1W,   manualC1W)

pointA1D   = getABCPoint(tf1D.pivotA,   autoABC1D,   manualA1D)
pointB1D   = getABCPoint(tf1D.pivotB,   autoABC1D,   manualB1D)
pointC1D   = getABCPoint(tf1D.pivotC,   autoABC1D,   manualC1D)

pointA4H   = getABCPoint(tf4H.pivotA,   autoABC4H,   manualA4H)
pointB4H   = getABCPoint(tf4H.pivotB,   autoABC4H,   manualB4H)
pointC4H   = getABCPoint(tf4H.pivotC,   autoABC4H,   manualC4H)

pointA1H   = getABCPoint(tf1H.pivotA,   autoABC1H,   manualA1H)
pointB1H   = getABCPoint(tf1H.pivotB,   autoABC1H,   manualB1H)
pointC1H   = getABCPoint(tf1H.pivotC,   autoABC1H,   manualC1H)

pointA15m  = getABCPoint(tf15m.pivotA,  autoABC15m,  manualA15m)
pointB15m  = getABCPoint(tf15m.pivotB,  autoABC15m,  manualB15m)
pointC15m  = getABCPoint(tf15m.pivotC,  autoABC15m,  manualC15m)

pointA1min = getABCPoint(tf1min.pivotA, autoABC1min, manualA1min)
pointB1min = getABCPoint(tf1min.pivotB, autoABC1min, manualB1min)
pointC1min = getABCPoint(tf1min.pivotC, autoABC1min, manualC1min)

// =============================================================================
// TREND ANALYSIS
// =============================================================================

getTrendSignal(float rsiVal, float macdHistVal) =>
    rsiSig = rsiVal >= 60 ? 1.0 : (rsiVal <= 40 ? -1.0 : (rsiVal > 50 ? 0.5 : (rsiVal < 50 ? -0.5 : 0.0)))
    macdSig = macdHistVal > 0 ? 1.0 : (macdHistVal < 0 ? -1.0 : 0.0)
    (rsiSig * 0.5) + (macdSig * 0.5)

getTrendDir(float score) =>
    score >= 0.3 ? "BULL" : (score <= -0.3 ? "BEAR" : "RANG")

getTrendCol(string trend) =>
    trend == "BULL" ? color.lime : (trend == "BEAR" ? color.red : color.gray)

// =============================================================================
// DRAWING ARRAYS
// =============================================================================

var array<line> fibLines = array.new<line>()
var array<label> fibLabels = array.new<label>()
var array<label> swingLabels = array.new<label>()
var array<line> swingMarkerLines = array.new<line>()
var array<line> swingConnectLines = array.new<line>()

clearDrawings() =>
    for ln in fibLines
        line.delete(ln)
    array.clear(fibLines)
    for lb in fibLabels
        label.delete(lb)
    array.clear(fibLabels)
    for lb in swingLabels
        label.delete(lb)
    array.clear(swingLabels)
    for ln in swingMarkerLines
        line.delete(ln)
    array.clear(swingMarkerLines)
    for ln in swingConnectLines
        line.delete(ln)
    array.clear(swingConnectLines)

// Draw single Fib level (with per-TF settings)
drawFib(float price, string tfName, string ratioText, string fibType, color tfColor, bool showLabel, bool extendLine, bool showPrice, int lineLen) =>
    if not na(price)
        extStyle = extendLine ? extend.right : extend.none
        newLine = line.new(bar_index - lineLen, price, bar_index, price,
            xloc.bar_index, extStyle, tfColor, line.style_dashed, 1)
        array.push(fibLines, newLine)

        if showLabel
            txt = tfName + " " + fibType + " " + ratioText
            if showPrice
                txt := txt + " " + str.tostring(price, format.mintick)
            newLbl = label.new(bar_index, price, txt,
                xloc.bar_index, yloc.price, color.new(tfColor, 80), label.style_label_left, tfColor, size.tiny)
            array.push(fibLabels, newLbl)

// Draw swing marker (horizontal line + label) with per-TF settings
drawSwing(float price, string tfName, bool isHigh, color tfColor, bool showLabel, bool showLine, bool showPrice, int lineLen) =>
    if not na(price)
        // Draw horizontal marker line at the swing level (short line for visibility)
        if showLine
            lineWidth = 2
            markerLine = line.new(bar_index - lineLen, price, bar_index, price,
                xloc.bar_index, extend.none, tfColor, line.style_solid, lineWidth)
            array.push(swingMarkerLines, markerLine)

        // Draw label if enabled
        if showLabel
            txt = tfName + (isHigh ? " H" : " L")
            if showPrice
                txt := txt + " " + str.tostring(price, format.mintick)
            style = isHigh ? label.style_label_down : label.style_label_up
            newLbl = label.new(bar_index, price, txt,
                xloc.bar_index, yloc.price, color.new(tfColor, 70), style, tfColor, size.small)
            array.push(swingLabels, newLbl)

// Draw connecting line between swing high and swing low
drawSwingConnection(float highPrice, float lowPrice, color tfColor, bool showLine, int lineLen) =>
    if not na(highPrice) and not na(lowPrice) and showLine
        // Draw diagonal line from high to low (offset positions based on line length)
        startOffset = math.round(lineLen * 0.75)
        endOffset = math.round(lineLen * 0.25)
        connectLine = line.new(bar_index - startOffset, highPrice, bar_index - endOffset, lowPrice,
            xloc.bar_index, extend.none, tfColor, line.style_dotted, 1)
        array.push(swingConnectLines, connectLine)

// Draw ABC swing markers with solid lines for all 3 points
// A = oldest pivot, B = middle pivot, C = most recent pivot (alternating pattern)
drawABCMarkers(float pointA, float pointB, float pointC, string tfName, color tfColor, bool showLabel, bool showLine, bool showPrice, int lineLen) =>
    if showLine
        // Point A marker (oldest - furthest back)
        if not na(pointA)
            aOffset = math.round(lineLen * 1.5)
            aEndOffset = math.round(lineLen * 1.2)
            markerLineA = line.new(bar_index - aOffset, pointA, bar_index - aEndOffset, pointA,
                xloc.bar_index, extend.none, tfColor, line.style_solid, 2)
            array.push(swingMarkerLines, markerLineA)
            if showLabel
                txtA = tfName + " A"
                if showPrice
                    txtA := txtA + " " + str.tostring(pointA, format.mintick)
                lblA = label.new(bar_index - aOffset, pointA, txtA,
                    xloc.bar_index, yloc.price, color.new(tfColor, 80), label.style_label_left, tfColor, size.small)
                array.push(swingLabels, lblA)

        // Point B marker (middle)
        if not na(pointB)
            bOffset = math.round(lineLen * 0.9)
            bEndOffset = math.round(lineLen * 0.6)
            markerLineB = line.new(bar_index - bOffset, pointB, bar_index - bEndOffset, pointB,
                xloc.bar_index, extend.none, tfColor, line.style_solid, 2)
            array.push(swingMarkerLines, markerLineB)
            if showLabel
                txtB = tfName + " B"
                if showPrice
                    txtB := txtB + " " + str.tostring(pointB, format.mintick)
                lblB = label.new(bar_index - bOffset, pointB, txtB,
                    xloc.bar_index, yloc.price, color.new(tfColor, 80), label.style_label_left, tfColor, size.small)
                array.push(swingLabels, lblB)

        // Point C marker (most recent - closest to current bar)
        if not na(pointC)
            cOffset = math.round(lineLen * 0.4)
            cEndOffset = math.round(lineLen * 0.1)
            markerLineC = line.new(bar_index - cOffset, pointC, bar_index - cEndOffset, pointC,
                xloc.bar_index, extend.none, tfColor, line.style_solid, 2)
            array.push(swingMarkerLines, markerLineC)
            if showLabel
                txtC = tfName + " C"
                if showPrice
                    txtC := txtC + " " + str.tostring(pointC, format.mintick)
                lblC = label.new(bar_index - cOffset, pointC, txtC,
                    xloc.bar_index, yloc.price, color.new(tfColor, 80), label.style_label_left, tfColor, size.small)
                array.push(swingLabels, lblC)

// Draw ABC connecting lines (A→B→C diagonal lines)
drawABCConnections(float pointA, float pointB, float pointC, color tfColor, bool showLine, int lineLen) =>
    if showLine
        aOffset = math.round(lineLen * 1.35)
        bOffset = math.round(lineLen * 0.75)
        cOffset = math.round(lineLen * 0.25)

        // A→B connecting line
        if not na(pointA) and not na(pointB)
            lineAB = line.new(bar_index - aOffset, pointA, bar_index - bOffset, pointB,
                xloc.bar_index, extend.none, tfColor, line.style_solid, 1)
            array.push(swingConnectLines, lineAB)

        // B→C connecting line
        if not na(pointB) and not na(pointC)
            lineBC = line.new(bar_index - bOffset, pointB, bar_index - cOffset, pointC,
                xloc.bar_index, extend.none, tfColor, line.style_solid, 1)
            array.push(swingConnectLines, lineBC)

// =============================================================================
// DRAW ALL LEVELS FOR A TIMEFRAME
// =============================================================================

// Per-TF Fib drawing with separate strategy ratios
// swingDir: "down" = last pivot was LOW (BUY setup), "up" = last pivot was HIGH (SELL setup)
drawTFLevels(
    float swingH, float swingL, float prevH, string swingDir,
    string tfName, color tfColor,
    bool showLabel, bool extendLine, bool showPrice, int lineLen,
    bool showRet, bool rR236, bool rR382, bool rR500, bool rR618, bool rR786,
    bool showExt, bool rE1272, bool rE1618, bool rE2000, bool rE2618,
    bool showProj, bool rP618, bool rP786, bool rP1000, bool rP1272, bool rP1618,
    bool showExp, bool rX382, bool rX500, bool rX618, bool rX1000, bool rX1618) =>

    if not na(swingH) and not na(swingL)
        rangeH = math.max(swingH, swingL)
        rangeL = math.min(swingH, swingL)
        // Use the passed direction based on which pivot came last:
        // "down" = last was LOW = BUY setup (levels below for entry, above for targets)
        // "up" = last was HIGH = SELL setup (levels above for entry, below for targets)
        dir = swingDir

        // RETRACEMENT
        if showRet
            if rR236
                drawFib(calcRetracement(rangeH, rangeL, dir, 0.236), tfName, "23.6%", "R", tfColor, showLabel, extendLine, showPrice, lineLen)
            if rR382
                drawFib(calcRetracement(rangeH, rangeL, dir, 0.382), tfName, "38.2%", "R", tfColor, showLabel, extendLine, showPrice, lineLen)
            if rR500
                drawFib(calcRetracement(rangeH, rangeL, dir, 0.500), tfName, "50%", "R", tfColor, showLabel, extendLine, showPrice, lineLen)
            if rR618
                drawFib(calcRetracement(rangeH, rangeL, dir, 0.618), tfName, "61.8%", "R", tfColor, showLabel, extendLine, showPrice, lineLen)
            if rR786
                drawFib(calcRetracement(rangeH, rangeL, dir, 0.786), tfName, "78.6%", "R", tfColor, showLabel, extendLine, showPrice, lineLen)

        // EXTENSION
        if showExt
            if rE1272
                drawFib(calcExtension(rangeH, rangeL, dir, 1.272), tfName, "127.2%", "E", tfColor, showLabel, extendLine, showPrice, lineLen)
            if rE1618
                drawFib(calcExtension(rangeH, rangeL, dir, 1.618), tfName, "161.8%", "E", tfColor, showLabel, extendLine, showPrice, lineLen)
            if rE2000
                drawFib(calcExtension(rangeH, rangeL, dir, 2.000), tfName, "200%", "E", tfColor, showLabel, extendLine, showPrice, lineLen)
            if rE2618
                drawFib(calcExtension(rangeH, rangeL, dir, 2.618), tfName, "261.8%", "E", tfColor, showLabel, extendLine, showPrice, lineLen)

        // PROJECTION (needs 3 points: prevH, swingH, swingL as A, B, C)
        if showProj and not na(prevH)
            pointA = prevH
            pointB = swingH
            pointC = swingL
            if rP618
                drawFib(calcProjection(pointA, pointB, pointC, dir, 0.618), tfName, "61.8%", "P", tfColor, showLabel, extendLine, showPrice, lineLen)
            if rP786
                drawFib(calcProjection(pointA, pointB, pointC, dir, 0.786), tfName, "78.6%", "P", tfColor, showLabel, extendLine, showPrice, lineLen)
            if rP1000
                drawFib(calcProjection(pointA, pointB, pointC, dir, 1.000), tfName, "100%", "P", tfColor, showLabel, extendLine, showPrice, lineLen)
            if rP1272
                drawFib(calcProjection(pointA, pointB, pointC, dir, 1.272), tfName, "127.2%", "P", tfColor, showLabel, extendLine, showPrice, lineLen)
            if rP1618
                drawFib(calcProjection(pointA, pointB, pointC, dir, 1.618), tfName, "161.8%", "P", tfColor, showLabel, extendLine, showPrice, lineLen)

        // EXPANSION (from swingH to swingL)
        if showExp
            if rX382
                drawFib(calcExpansion(swingH, swingL, dir, 0.382), tfName, "38.2%", "X", tfColor, showLabel, extendLine, showPrice, lineLen)
            if rX500
                drawFib(calcExpansion(swingH, swingL, dir, 0.500), tfName, "50%", "X", tfColor, showLabel, extendLine, showPrice, lineLen)
            if rX618
                drawFib(calcExpansion(swingH, swingL, dir, 0.618), tfName, "61.8%", "X", tfColor, showLabel, extendLine, showPrice, lineLen)
            if rX1000
                drawFib(calcExpansion(swingH, swingL, dir, 1.000), tfName, "100%", "X", tfColor, showLabel, extendLine, showPrice, lineLen)
            if rX1618
                drawFib(calcExpansion(swingH, swingL, dir, 1.618), tfName, "161.8%", "X", tfColor, showLabel, extendLine, showPrice, lineLen)

// =============================================================================
// MAIN DRAWING LOGIC
// =============================================================================

if barstate.islast
    clearDrawings()

    // 1M (longest lines - highest TF)
    // Draw if TF request is valid OR if we have data (handles same-TF edge cases)
    if enable1M and (isValidTFRequest(TF_1M) or hasValidABCData(pointA1M, pointB1M, pointC1M))
        drawABCMarkers(pointA1M, pointB1M, pointC1M, "1M", col1M, showLabels1M, showLines1M, showPrice1M, lineLen1M)
        drawABCConnections(pointA1M, pointB1M, pointC1M, col1M, showLines1M, lineLen1M)
        drawTFLevels(tf1M.lastH, tf1M.lastL, pointA1M, getSwingDir(tf1M.lastType), "1M", col1M,
            showLabels1M, extendFib1M, showPrice1M, lineLen1M,
            ret1M, r1M_R236, r1M_R382, r1M_R500, r1M_R618, r1M_R786,
            ext1M, r1M_E1272, r1M_E1618, r1M_E2000, r1M_E2618,
            proj1M, r1M_P618, r1M_P786, r1M_P1000, r1M_P1272, r1M_P1618,
            exp1M, r1M_X382, r1M_X500, r1M_X618, r1M_X1000, r1M_X1618)

    // 1W
    if enable1W and (isValidTFRequest(TF_1W) or hasValidABCData(pointA1W, pointB1W, pointC1W))
        drawABCMarkers(pointA1W, pointB1W, pointC1W, "1W", col1W, showLabels1W, showLines1W, showPrice1W, lineLen1W)
        drawABCConnections(pointA1W, pointB1W, pointC1W, col1W, showLines1W, lineLen1W)
        drawTFLevels(tf1W.lastH, tf1W.lastL, pointA1W, getSwingDir(tf1W.lastType), "1W", col1W,
            showLabels1W, extendFib1W, showPrice1W, lineLen1W,
            ret1W, r1W_R236, r1W_R382, r1W_R500, r1W_R618, r1W_R786,
            ext1W, r1W_E1272, r1W_E1618, r1W_E2000, r1W_E2618,
            proj1W, r1W_P618, r1W_P786, r1W_P1000, r1W_P1272, r1W_P1618,
            exp1W, r1W_X382, r1W_X500, r1W_X618, r1W_X1000, r1W_X1618)

    // 1D
    if enable1D and (isValidTFRequest(TF_1D) or hasValidABCData(pointA1D, pointB1D, pointC1D))
        drawABCMarkers(pointA1D, pointB1D, pointC1D, "1D", col1D, showLabels1D, showLines1D, showPrice1D, lineLen1D)
        drawABCConnections(pointA1D, pointB1D, pointC1D, col1D, showLines1D, lineLen1D)
        drawTFLevels(tf1D.lastH, tf1D.lastL, pointA1D, getSwingDir(tf1D.lastType), "1D", col1D,
            showLabels1D, extendFib1D, showPrice1D, lineLen1D,
            ret1D, r1D_R236, r1D_R382, r1D_R500, r1D_R618, r1D_R786,
            ext1D, r1D_E1272, r1D_E1618, r1D_E2000, r1D_E2618,
            proj1D, r1D_P618, r1D_P786, r1D_P1000, r1D_P1272, r1D_P1618,
            exp1D, r1D_X382, r1D_X500, r1D_X618, r1D_X1000, r1D_X1618)

    // 4H
    if enable4H and (isValidTFRequest(TF_4H) or hasValidABCData(pointA4H, pointB4H, pointC4H))
        drawABCMarkers(pointA4H, pointB4H, pointC4H, "4H", col4H, showLabels4H, showLines4H, showPrice4H, lineLen4H)
        drawABCConnections(pointA4H, pointB4H, pointC4H, col4H, showLines4H, lineLen4H)
        drawTFLevels(tf4H.lastH, tf4H.lastL, pointA4H, getSwingDir(tf4H.lastType), "4H", col4H,
            showLabels4H, extendFib4H, showPrice4H, lineLen4H,
            ret4H, r4H_R236, r4H_R382, r4H_R500, r4H_R618, r4H_R786,
            ext4H, r4H_E1272, r4H_E1618, r4H_E2000, r4H_E2618,
            proj4H, r4H_P618, r4H_P786, r4H_P1000, r4H_P1272, r4H_P1618,
            exp4H, r4H_X382, r4H_X500, r4H_X618, r4H_X1000, r4H_X1618)

    // 1H
    if enable1H and (isValidTFRequest(TF_1H) or hasValidABCData(pointA1H, pointB1H, pointC1H))
        drawABCMarkers(pointA1H, pointB1H, pointC1H, "1H", col1H, showLabels1H, showLines1H, showPrice1H, lineLen1H)
        drawABCConnections(pointA1H, pointB1H, pointC1H, col1H, showLines1H, lineLen1H)
        drawTFLevels(tf1H.lastH, tf1H.lastL, pointA1H, getSwingDir(tf1H.lastType), "1H", col1H,
            showLabels1H, extendFib1H, showPrice1H, lineLen1H,
            ret1H, r1H_R236, r1H_R382, r1H_R500, r1H_R618, r1H_R786,
            ext1H, r1H_E1272, r1H_E1618, r1H_E2000, r1H_E2618,
            proj1H, r1H_P618, r1H_P786, r1H_P1000, r1H_P1272, r1H_P1618,
            exp1H, r1H_X382, r1H_X500, r1H_X618, r1H_X1000, r1H_X1618)

    // 15m
    if enable15m and (isValidTFRequest(TF_15m) or hasValidABCData(pointA15m, pointB15m, pointC15m))
        drawABCMarkers(pointA15m, pointB15m, pointC15m, "15m", col15m, showLabels15m, showLines15m, showPrice15m, lineLen15m)
        drawABCConnections(pointA15m, pointB15m, pointC15m, col15m, showLines15m, lineLen15m)
        drawTFLevels(tf15m.lastH, tf15m.lastL, pointA15m, getSwingDir(tf15m.lastType), "15m", col15m,
            showLabels15m, extendFib15m, showPrice15m, lineLen15m,
            ret15m, r15m_R236, r15m_R382, r15m_R500, r15m_R618, r15m_R786,
            ext15m, r15m_E1272, r15m_E1618, r15m_E2000, r15m_E2618,
            proj15m, r15m_P618, r15m_P786, r15m_P1000, r15m_P1272, r15m_P1618,
            exp15m, r15m_X382, r15m_X500, r15m_X618, r15m_X1000, r15m_X1618)

    // 1m (shortest lines - lowest TF)
    if enable1min and (isValidTFRequest(TF_1m) or hasValidABCData(pointA1min, pointB1min, pointC1min))
        drawABCMarkers(pointA1min, pointB1min, pointC1min, "1m", col1min, showLabels1min, showLines1min, showPrice1min, lineLen1min)
        drawABCConnections(pointA1min, pointB1min, pointC1min, col1min, showLines1min, lineLen1min)
        drawTFLevels(tf1min.lastH, tf1min.lastL, pointA1min, getSwingDir(tf1min.lastType), "1m", col1min,
            showLabels1min, extendFib1min, showPrice1min, lineLen1min,
            ret1min, r1min_R236, r1min_R382, r1min_R500, r1min_R618, r1min_R786,
            ext1min, r1min_E1272, r1min_E1618, r1min_E2000, r1min_E2618,
            proj1min, r1min_P618, r1min_P786, r1min_P1000, r1min_P1272, r1min_P1618,
            exp1min, r1min_X382, r1min_X500, r1min_X618, r1min_X1000, r1min_X1618)

// =============================================================================
// TREND ALIGNMENT TABLE
// =============================================================================

var table trendTbl = table.new(position.top_right, 10, 10, bgcolor=color.new(color.black, 80), border_width=1)

if barstate.islast and showTrendPanel
    // Header
    table.cell(trendTbl, 0, 0, "TF", text_color=color.white, text_size=size.small)
    table.cell(trendTbl, 1, 0, "A", text_color=color.yellow, text_size=size.small, tooltip="Point A (oldest alternating pivot)")
    table.cell(trendTbl, 2, 0, "B", text_color=color.lime, text_size=size.small, tooltip="Point B (middle alternating pivot)")
    table.cell(trendTbl, 3, 0, "C", text_color=color.aqua, text_size=size.small, tooltip="Point C (most recent alternating pivot)")
    table.cell(trendTbl, 4, 0, "Trend", text_color=color.white, text_size=size.small)
    table.cell(trendTbl, 5, 0, "RSI", text_color=color.white, text_size=size.small)
    table.cell(trendTbl, 6, 0, "MACD", text_color=color.white, text_size=size.small)
    table.cell(trendTbl, 7, 0, "L/R", text_color=color.white, text_size=size.small, tooltip="Left/Right bars for pivot detection")

    bullCount = 0
    bearCount = 0
    row = 1

    // Draw each enabled timeframe row
    if enable1M
        d = drawTrendRow(trendTbl, row, "1M", col1M, autoABC1M, pointA1M, pointB1M, pointC1M, rsi1M, mh1M, lb1M, fwd1M)
        bullCount += d == "BULL" ? 1 : 0
        bearCount += d == "BEAR" ? 1 : 0
        row += 1

    if enable1W
        d = drawTrendRow(trendTbl, row, "1W", col1W, autoABC1W, pointA1W, pointB1W, pointC1W, rsi1W, mh1W, lb1W, fwd1W)
        bullCount += d == "BULL" ? 1 : 0
        bearCount += d == "BEAR" ? 1 : 0
        row += 1

    if enable1D
        d = drawTrendRow(trendTbl, row, "1D", col1D, autoABC1D, pointA1D, pointB1D, pointC1D, rsi1D, mh1D, lb1D, fwd1D)
        bullCount += d == "BULL" ? 1 : 0
        bearCount += d == "BEAR" ? 1 : 0
        row += 1

    if enable4H
        d = drawTrendRow(trendTbl, row, "4H", col4H, autoABC4H, pointA4H, pointB4H, pointC4H, rsi4H, mh4H, lb4H, fwd4H)
        bullCount += d == "BULL" ? 1 : 0
        bearCount += d == "BEAR" ? 1 : 0
        row += 1

    if enable1H
        d = drawTrendRow(trendTbl, row, "1H", col1H, autoABC1H, pointA1H, pointB1H, pointC1H, rsi1H, mh1H, lb1H, fwd1H)
        bullCount += d == "BULL" ? 1 : 0
        bearCount += d == "BEAR" ? 1 : 0
        row += 1

    if enable15m
        d = drawTrendRow(trendTbl, row, "15m", col15m, autoABC15m, pointA15m, pointB15m, pointC15m, rsi15m, mh15m, lb15m, fwd15m)
        bullCount += d == "BULL" ? 1 : 0
        bearCount += d == "BEAR" ? 1 : 0
        row += 1

    if enable1min
        d = drawTrendRow(trendTbl, row, "1m", col1min, autoABC1min, pointA1min, pointB1min, pointC1min, rsi1min, mh1min, lb1min, fwd1min)
        bullCount += d == "BULL" ? 1 : 0
        bearCount += d == "BEAR" ? 1 : 0
        row += 1

    // Overall
    totalEnabled = (enable1M ? 1 : 0) + (enable1W ? 1 : 0) + (enable1D ? 1 : 0) +
                   (enable4H ? 1 : 0) + (enable1H ? 1 : 0) + (enable15m ? 1 : 0) + (enable1min ? 1 : 0)
    overallDir = bullCount > bearCount ? "BULLISH" : (bearCount > bullCount ? "BEARISH" : "MIXED")
    overallCol = bullCount > bearCount ? color.lime : (bearCount > bullCount ? color.red : color.gray)

    table.cell(trendTbl, 0, row, "ALL", text_color=color.white, text_size=size.small, bgcolor=color.new(overallCol, 60))
    table.cell(trendTbl, 1, row, "", text_size=size.tiny)
    table.cell(trendTbl, 2, row, "", text_size=size.tiny)
    table.cell(trendTbl, 3, row, "", text_size=size.tiny)
    table.cell(trendTbl, 4, row, overallDir, text_color=overallCol, text_size=size.small, bgcolor=color.new(overallCol, 80))
    table.cell(trendTbl, 5, row, str.tostring(bullCount) + "/" + str.tostring(totalEnabled), text_color=color.white, text_size=size.tiny)
    table.cell(trendTbl, 6, row, "Bull", text_color=color.white, text_size=size.tiny)
    table.cell(trendTbl, 7, row, "", text_size=size.tiny)
